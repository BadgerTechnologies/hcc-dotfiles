" vim: set et sw=4 foldmethod=marker foldmarker={{{,}}}:

"====[ Basic options ]================================================== {{{1
" Use vim settings, not vi (yuck!)
set nocompatible

set wrap           " wrap long lines in the window
set nolinebreak    " wrap exactly at window edge, not between words
set sw=8           " Shift width - how much to indent with tab key
set ts=8           " Tab stop - how far a tab char indents
set smarttab
set autoindent
set history=500    " This is the : cmd history. Use up arrorw for prev commands
set ruler          " Always show a window status line, even when only 1 win
set showcmd        " Show partially typed commands in status area
set incsearch      " Incremental search
set ignorecase     " the case of normal letters is ignored
set smartcase      " upper case letters in search turn off ignorecase
set wrapscan       " wrap to top of file on search
set cinoptions=(0l1
set showmatch      " When a bracket is inserted, briefly jump to the matching.
set whichwrap=,,<,>,[,],b,s
set hlsearch       " Highlight search results as
set gdefault       " assume the /g flag on :s substitutions to replace all matches in a line
set shell=/bin/zsh
set modeline       " read modelines
set modelines=5    " number of lines from top and bottom of file
filetype on        " Detect file types
set showfulltag    " Insert mode completion of tag shows whole funct prototype!
set hidden         " Allow a modified buffer to be not displayed in a window
colorscheme hcc
syntax on
set laststatus=2   " Always show a status line, even when only 1 window
" silent! suppresses error message for older Vim's that lack the option
silent! set colorcolumn=81 " Make the 81st column stand out (ColorColumn highlight)
set noswapfile     " Swap files are so annoying!
set number         " Mapping to toggle this: con (vim-unimpaired plugin)
silent! set relativenumber " cor  "   "    "     "
set cursorcolumn   " cox
set cursorline     " cox
behave xterm       " Mouse drag enters Visual mode instead of Select mode.
                   " behave sets several options. See help
set nostartofline
set path+=**       " File operations recurse directories

" New windows open below or to right of current one (why isn't this default?)
set splitbelow
set splitright

" Format Options
set formatoptions+=j " Delete comment char when joining commented lines
set formatoptions-=o " (don't) Insert the comment leader after hitting 'o' etc.
set textwidth=78
set formatoptions+=c " Auto-format comments in insert mode

" Tighter X server clipboard integration. Of these unnamed and unnamedplus
" are added to the defaults.
set clipboard=unnamed,unnamedplus,autoselect,exclude:cons\|linux

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

" make the completion mode behave more like bash -- complete the longest
" string, then list the alternatives.  as an added bonus, revert to the
" normal cycle-through behavior for later tabbing.
set wildmode=longest:full
set wildmenu
" I think this is the default: set wildchar=<Tab>

" Leader
let mapleader = ","
let maplocalleader = "\\"

augroup hcc_indents
autocmd!
" hardware tabs are special in makefiles, don't expand them
autocmd FileType make set noexpandtab shiftwidth=8
autocmd FileType c set noexpandtab shiftwidth=8
autocmd FileType python,sh,perl set expandtab shiftwidth=4
augroup END

" Make PgUp and PgDn keep the cursor on the same line of the screen
" http://vimrc-dissection.blogspot.com/2009/02/fixing-pageup-and-pagedown.html
map <silent> <PageUp> 1000<C-U>
map <silent> <PageDown> 1000<C-D>
imap <silent> <PageUp> <C-b>1000<C-U>
imap <silent> <PageDown> <C-b>1000<C-D>


set tags=tags,../tags,../../tags,../../../tags,../../../../tags


" Be a little bit more Common User Interface-like
set virtualedit=onemore,block
nmap <End> $l

" Temp disable some cpoptions that might affect the following bindings
" I'm not really sure this matters
let s:save_cpo = &cpoptions
set cpo&vim

"====[ General Purpose Mappings ]======================================= {{{1
" backspace in Visual mode deletes selection
" vnoremap <BS> d

" SHIFT-Del is Cut
vnoremap <S-Del> "+x

" CTRL-Insert is Copy
vnoremap <C-Insert> "+y

" SHIFT-Insert is Paste (normal/visual, insert, and command-edit modes)
map <S-Insert>		"+gP
imap <S-Insert>		<C-o>"+gP
cmap <S-Insert>		<C-R>+

" Disable ZZ = :x to prevent accidental write when using zz with capslock on
map ZZ zz

" restore 'cpoptions'
set cpo&
let &cpoptions = s:save_cpo
unlet s:save_cpo

map <leader>rc :source ~/.vimrc<CR>:source ~/.gvimrc<CR>

" Like "Refresh" in a web browser. Center line with cursor and redraw screen.
map <F5> :norm zz<CR>:redraw!<CR>

" Kill current buffer without closing the window that it occupies.
map <leader>c :bp<CR>:bd#<CR>

" Enable / Disable Mouse mode (for use when running in terminal)
" Makes resizing splits mucc less painful
map <F9> :set mouse=a
map <S-F9> :set mouse=
set mouse=a  " Let's default to mouse On
set ttymouse=sgr   " Take advantage reasonable term support for mouse

" Scroll window up or down a bit, preserving cursor pos in buffer:
map <C-Down> <C-E>
map <C-Up> <C-Y>

" Make CTRL-] show tab select list iff more than one match
map <C-]> g<C-]>

" Better than typing Esc:
:inoremap  jk <Esc>
:cnoremap  jk <Esc>
:onoremap  jk <Esc>
:snoremap  jk <Esc>
:inoremap  kj <Esc>
:cnoremap  kj <Esc>
:onoremap  kj <Esc>
:snoremap  kj <Esc>

" Toggle whether to use git grep vs. standard grep. The lhs of these mappings
" follows the conventions for toggle mappings in vim-unimpaired plugin.:w
:nmap ]og   :set grepprg=git\ grep\ -n\ $*<CR>
:nmap [og   :set grepprg=grep\ -r\ -n\ $*\ .<CR>
:nmap cog   :normal <C-R>=match(&grepprg, "^git") > -1 ? "[og" : "]og"<CR><CR>

" Source line or visual selection
nnoremap <leader>S ^"zy$:@z<cr>:echo 'sourced line.'<cr>
vnoremap <leader>S "zy:@z<cr>:echo 'Sourced selection.'<cr>

" Semi-colons are a much more convenient way to start a colon-command!
nnoremap ;  :
" However, the "repeat last motion" command is useful, so make Enter do that
" BUT, we want <Enter> to do it's normal thing in the QuickFix window, so
" we have to use a helper function
function! Repeat_last_motion_except_in_quickfix()
  if &buftype ==# 'quickfix'
    execute "normal! \<CR>"
  else
    normal! ;
  endif
endfunction

nnoremap <silent> <CR> :call Repeat_last_motion_except_in_quickfix()<CR>

" Tab Control. {{{2
:nnoremap gh :tabprev<CR>       " Overrides gh (start Select mode linewise)
:nnoremap gl :tabnext<CR>
:nnoremap gH :tabfirst<CR>
:nnoremap gL :tablast<CR>
:nnoremap g<Enter> :tabnew<CR>  " Don't want to override gn
:nnoremap gc :tabclose<CR>
:nnoremap g<C-H> :tabmove -1<CR> " Override start Select mode blockwise)
:nnoremap g<C-L> :tabmove +1<CR>

" Functions to move current window to next / prev tab, since not built-in
" From: http://vim.wikia.com/wiki/Move_current_window_between_tabs
function! MoveToPrevTab()
  "there is only one window
  if tabpagenr('$') == 1 && winnr('$') == 1
    return
  endif
  "preparing new window
  let l:tab_nr = tabpagenr('$')
  let l:cur_buf = bufnr('%')
  if tabpagenr() != 1
    close!
    if l:tab_nr == tabpagenr('$')
      tabprev
    endif
    sp
    wincmd j
  else
    close!
    exe "0tabnew"
  endif
  "opening current buffer in new window
  exe "b".l:cur_buf
endfunc

function! MoveToNextTab()
  "there is only one window
  if tabpagenr('$') == 1 && winnr('$') == 1
    return
  endif
  "preparing new window
  let l:tab_nr = tabpagenr('$')
  let l:cur_buf = bufnr('%')
  if tabpagenr() < l:tab_nr
    close!
    if l:tab_nr == tabpagenr('$')
      tabnext
    endif
    sp
    wincmd j
  else
    close!
    tabnew
  endif
  "opening current buffer in new window
  exe "b".l:cur_buf
endfunc

" Map g+Alt-L, g+Alt-H to these functions. Unfortunately, vim doesn't
" recognize what tmux sends as an Alt + character (which is Esc + character).
" These "set" commands fix that, as explained here:
" http://stackoverflow.com/questions/7501092/can-i-map-alt-key-in-vim
set <A-L>=l
:nnoremap g<A-L> :call MoveToNextTab()<CR>
set <A-H>=h
:nnoremap g<A-H> :call MoveToPrevTab()<CR>
" }}}2

" Window Control. Use <space> as alias for Ctrl-W {{{2
" I hate typing Ctrl-W, especially since this means "close tab or window" in
" other applications, which is bad if focus isn't where I think it is!
" And <space> has no real function in Normal mode.

" Not included: S
" ToDo: Decide to not include some more of the below, then those mappings are
" available for other things.
:nnoremap <Space>+  <C-W>+
:nnoremap <Space>-  <C-W>-
:nnoremap <Space><  <C-W><
:nnoremap <Space>=  <C-W>=
:nnoremap <Space>>  <C-W>>
:nnoremap <Space>H  <C-W>H
:nnoremap <Space>J  <C-W>J
:nnoremap <Space>K  <C-W>K
:nnoremap <Space>L  <C-W>L
:nnoremap <Space>P  <C-W>P
:nnoremap <Space>R  <C-W>R
:nnoremap <Space>T  <C-W>T
:nnoremap <Space>W  <C-W>W
:nnoremap <Space>]  <C-W>]
:nnoremap <Space>^  <C-W>^
:nnoremap <Space>_  <C-W>_
:nnoremap <Space>b  <C-W>b
:nnoremap <Space>c  <C-W>c
:nnoremap <Space>d  <C-W>d
:nnoremap <Space>f  <C-W>f
:nnoremap <Space>F  <C-W>F
:nnoremap <Space>W  <C-W>W
:nnoremap <Space>g<C-]>  <C-W>g<C-]>
:nnoremap <Space>g] <C-W>g]
:nnoremap <Space>g} <C-W>g}
:nnoremap <Space>gf <C-W>gf
:nnoremap <Space>gF <C-W>gF
:nnoremap <Space>h  <C-W>h
:nnoremap <Space>i  <C-W>i
:nnoremap <Space>j  <C-W>j
:nnoremap <Space>k  <C-W>k
:nnoremap <Space>l  <C-W>l
:nnoremap <Space>n  <C-W>n
:nnoremap <Space>o  <C-W>o
:nnoremap <Space>p  <C-W>p
:nnoremap <Space>q  <C-W>q
:nnoremap <Space>r  <C-W>r
:nnoremap <Space>s  <C-W>s
:nnoremap <Space>t  <C-W>t
:nnoremap <Space>v  <C-W>v
:nnoremap <Space>w  <C-W>w
:nnoremap <Space>x  <C-W>x
:nnoremap <Space>z  <C-W>z
:nnoremap <Space><Bar>  <C-W><Bar>
:nnoremap <Space>}  <C-W>}
:nnoremap <Space><Down>  <C-W><Down>
:nnoremap <Space><Up>    <C-W><Up>
:nnoremap <Space><Left>  <C-W><Left>
:nnoremap <Space><Right> <C-W><Right>
" }}}2
" Window Control. Custom Mappings. {{{2

" Move current window up or down, staying within it
:nnoremap <Space><C-j>  <C-W>x<C-W>p
:nnoremap <Space><C-k>  <C-W>k<C-W>x
" ToDo: The above relies on "exchange", which works OK when there are only
" horizontal splits.  How to make it work for both vertical and horizontal
" splits?  Probably need to write a function that does something like this:
" save current window number in local var. Move in the direction indicated.
" Exchange the current window with the original one (arg to ^Wx, but is there
" a :command equivalent?) Bail if window motion didn't change current window
" number, which means we must have been at a limit.

" NOTE: Mapping to move current window into a split on the next or previous
" tab page is defined in the "Tab Control" section.

" }}}2


"====[ Abbreviations ]================================================== {{{1
" A few abbreviations for hcc:
" Kernel likes spaces after control-flow keywords, which is not what I'm used to:
" NOTE: Disable these for now. They don't work on LPDEV FC17 and RHEL5
" machines, and they're not all that useful anyways.
"" augroup hcc_c
"" autocmd!
"" autocmd filetype c iabbrev <buffer> if(      if (
"" autocmd filetype c iabbrev <buffer> for(     for (
"" autocmd filetype c iabbrev <buffer> while(   while (
"" autocmd filetype c iabbrev <buffer> switch(  switch (
"" autocmd filetype c iabbrev <buffer> iff      if () {<CR>;<CR><BS>}<Up><Up><End><Left><Left><Left>
"" autocmd filetype c iabbrev <buffer> forr     for (;;) {<CR>;<CR><BS>}<Up><Up><End><Left><Left><Left><Left><Left>
"" autocmd filetype c iabbrev <buffer> whilee   while () {<CR>;<CR><BS>}<Up><Up><End><Left><Left><Left>
"" augroup END


"====[ Highlight trailing whitespace brightly ]========================= {{{1

" This does not work on older VIM's that lack matchadd() & matchdelete():
if exists("*matchadd")
    " Enable or disable highlighting trailing whitespace for the current window.
    " Used with the augroup below. Original match regex came from:
    " https://github.com/peterlundgren/.home/blob/master/_vim/.vimrc
    function! EnableTrailingWhitespaceMatch(is_enable)
        if a:is_enable && !exists('w:trailing_whitespace_match')
            let w:trailing_whitespace_match = matchadd('ErrorMsg', '\s\+$\| \+\ze\t', -1)
        else
            if exists('w:trailing_whitespace_match')
                call matchdelete(w:trailing_whitespace_match)
                unlet w:trailing_whitespace_match
            endif
        endif
    endfunction

    " We have to use VimEnter & WinEnter to add the whitespace match separately
    " for each new window. However, it's annoying to see the red as I'm typing
    " so we'll toggle it OFF whenever we are in Insert mode.
    augroup TrailingWhitespaceGroup
        au!
        au VimEnter,WinEnter,InsertLeave * call EnableTrailingWhitespaceMatch(1)
        au InsertEnter * call EnableTrailingWhitespaceMatch(0)
    augroup END
endif " exists("*matchadd")


"====[ Shortcut to create header file double-inclusion guards ]========= {{{1

function! HeaderGuard ()
    " Include guard name is name of file, all upper case,
    " with all non-symbol chars replaced with underscore,
    " and with two leading underscores prepended
    let l:name = toupper(fnamemodify(bufname("%"), ":t"))
    let l:name = substitute(l:name, "[^A-Za-z0-9]", "_", "g")
    let l:name = '__' . l:name

    call append(0, '#ifndef ' . l:name)
    call append(1, '#define ' . l:name)
    call append(line('$'), '#endif  // ' . l:name)
endfunction
:command! HeaderGuard :call HeaderGuard()<CR>

source ~/.vim/hcc-vundle-conf.vim

"====[ QuickFix Window ]================================================ {{{1
"====[ Toggle QuickFix Window ]========================================= {{{2
" From: http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
command! -bang -nargs=? QFix call QFixToggle(<bang>0)
function! QFixToggle(forced)
    if exists("g:qfix_win") && a:forced == 0
        cclose
    else
        execute "copen | res " . g:Quickfix_Win_Height
    endif
endfunction

" used to track the quickfix window
augroup QFixToggle
    autocmd!
    autocmd BufWinEnter quickfix let g:qfix_win = bufnr("$")
    autocmd BufWinLeave * if exists("g:qfix_win") && expand("<abuf>") == g:qfix_win | unlet! g:qfix_win | endif
augroup END

" Howard's Settings for QuickFix toggle:
nmap Q :QFix<CR>
let g:Quickfix_Win_Height = 12

"====[ Preserve height of QuickFix when maximizing other windows ]======= {{{2
" From: https://gist.github.com/dahu/3344530
function! MaximizeWithoutResizingQuickfix()
    let l:qfwnr = get(get(filter(map(range(1,winnr('$')), '[v:val, getwinvar(v:val, "&buftype")]'), 'v:val[1] =~ "quickfix"'), 0, []), 0, -1)
    if (l:qfwnr !=# winnr())
        let l:qfh = winheight(qfwnr)
        wincmd _
        if qfwnr != -1
            exe qfwnr . "wincmd w"
            exe "resize " . qfh
            wincmd p
        endif
    endif
endfunction

" Howard's mappings for the above
" Quickly move up & down between split windows using ^j and ^k
map <silent> <C-J> <C-W>j:call MaximizeWithoutResizingQuickfix()<CR>
map <silent> <C-K> <C-W>k:call MaximizeWithoutResizingQuickfix()<CR>
" NOTE: To not have to see one line from the minimized windows, do :set mwh=0

"====[ Highlight matches when jumping to next ]========================= {{{1
" From: Damian Conway, "More Instantly Better Vim" - OSCON 2013

" This does not work on older VIM's that lack matchadd() & matchdelete():
if exists("*matchadd")

    " This rewires n and N to do the highlighing...
    nnoremap <silent> n   n:call HLNext(0.4)<cr>
    nnoremap <silent> N   N:call HLNext(0.4)<cr>


    " ring the match in red...
    function! HLNext (blinktime)
        highlight RedOnRed ctermfg=red ctermbg=red
        let [bufnum, lnum, col, off] = getpos('.')
        let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
        echo matchlen
        let ring_pat = (lnum > 1 ? '\%'.(lnum-1).'l\%>'.max([col-4,1]) .'v\%<'.(col+matchlen+3).'v.\|' : '')
                \ . '\%'.lnum.'l\%>'.max([col-4,1]) .'v\%<'.col.'v.'
                \ . '\|'
                \ . '\%'.lnum.'l\%>'.max([col+matchlen-1,1]) .'v\%<'.(col+matchlen+3).'v.'
                \ . '\|'
                \ . '\%'.(lnum+1).'l\%>'.max([col-4,1]) .'v\%<'.(col+matchlen+3).'v.'
        let ring = matchadd('RedOnRed', ring_pat, 101)
        redraw
        exec 'sleep ' . float2nr(0.5 * a:blinktime * 1000) . 'm'
        call matchdelete(ring)
        redraw
    endfunction
endif " exists("*matchadd")


"====[ Make it real obvious when we're in Insert mode by changing background ]= {{{1
" Would rather this be local to current window only, but there
" doesn't seem to be a way to control the definition of the Normal highlight
" on a per-window basis. I would also prefer the background to be a very
" dark red, but the darkest possile is still too bright.
augroup ToggleBackgroundInInsertMode
    au!
    au InsertEnter * :highlight Normal ctermbg=233 guibg=#121212
    au InsertLeave * :highlight Normal ctermbg=17 guibg=#00005f
augroup END

map <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
            \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
            \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

"====[ DiffOrig: Diff file with on-disk version ]======================= {{{1
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

"====[ vim-fugitive customization ]======================= {{{1

augroup hcc_fugitive
    autocmd!
    " When viewing a tree or blob, map .. to "move up a directory level"
    autocmd User fugitive  if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' | nnoremap <buffer> .. :edit %:h<CR> | endif
    autocmd BufReadPost fugitive://* set bufhidden=delete
augroup END


"====[ Experimental / Broken ]========================================== {{{1

" Filter current buffer to a new temporary buffer (i.e current buffer grep)
command! -nargs=0 Filter let @f='' | execute 'g//y F' | new | setlocal bt=nofile | put! f

" Same thing, but invert the filter, selecting lines that do NOT match
command! -nargs=0 FilterV let @f='' | execute 'v//y F' | new | setlocal bt=nofile | put! f
" Supposedly better/faster method using redir, but I couldn't get it to work:
" It would only copy first match into the buffer for reasons I don't fathom.
""command! -nargs=0 Filter redir @f> | g// | redir END | new | put! f
