
# Fix $SHELL, since we often inherited csh's idea of $SHELL
export SHELL=/bin/zsh

# Turn off Xon/Xoff in this termal so that can use <CTRL-Q> in progs like vim
stty start undef   # normally ^Q
stty stop undef    # normally ^S

# Make completions case-insensitive
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'

# Be very verbose with completions
zstyle ':completion:*' verbose yes 
zstyle ':completion:*:descriptions' format '%B%d%b' 
zstyle ':completion:*:messages' format '%d' 
zstyle ':completion:*:warnings' format 'No matches for: %d' 
zstyle ':completion:*' group-name ''

autoload -U compinit
compinit  # -C means just use cached .zcompdump unconditionally - CAUSED ERRORS

setopt PROMPT_SUBST # Allow parameter substitution in prompt

for file in ~/.zsh/zsh.d/*; do
    source $file
done

# Actually set my prompt.  Depends on already sourcing gencolors above
source ~/.zsh/setprompt

# Put this in front of a command to execute it only if prev command succeeded
# Allows easy piece-meal authoring of lines like cmd1 && cmd2 && cmd3
alias ok='[ $? -eq 0 ] && '

# Automatically list choices on an ambiguous completion.
setopt AUTO_LIST

# Make cd push the old directory onto the directory stack.
setopt AUTO_PUSHD PUSHD_MINUS

setopt NO_BG_NICE

setopt NO_CLOBBER

setopt NO_HUP

# If a pattern for filename generation has no matches, delete the pattern from the argument list; do not report an error unless all the patterns in a command have no matches. Overrides NOMATCH.
setopt CSH_NULL_GLOB

setopt EXTENDED_GLOB

setopt HIST_NO_STORE

# Whenever the user enters a line with history expansion, don't execute the line directly; instead, perform history expansion and reload the line into the editing buffer.
setopt HIST_VERIFY

# Do not exit on end-of-file.
setopt IGNORE_EOF

# (No) Beep on an ambiguous completion.
setopt NO_LIST_BEEP

# When listing files that are possible completions, show the type of each file with a trailing identifying mark.
setopt LIST_TYPES

# Don't print exit status when non-zero. My prompt does that already
unsetopt PRINT_EXIT_VALUE

# Perform implicit tees or cats when multiple redirections are attempted (see 6. Redirection).
setopt MULTIOS

# Report the status of background jobs immediately, rather than waiting until just before printing a prompt.
setopt NOTIFY

# Perform a path search even on command names with slashes in them.
setopt PATH_DIRS

# Perform foo=/path/to/filename expansion
setopt EQUALS

# long jobs listing
setopt long_list_jobs  # NOTE: Doesn't work...?? Workaround with alias:
alias jobs='jobs -l'
alias j='jobs -l'

# set ignore case for ls etc
setopt no_case_glob

# Recognize the # character in interactive command line
setopt INTERACTIVE_COMMENTS

# Split var references into words when values have spaces (like bash & tcsh)
setopt SH_WORD_SPLIT

# Disable ^S / ^Q flow control so can use ^Q for push-line
unsetopt FLOW_CONTROL

# automatically remove duplicates from these arrays
typeset -U path PATH cdpath fpath manpath MANPATH

# Prevent the prompt from overwriting the last line of output of a command
# if it does not end in a newline.
unsetopt promptcr

limit coredumpsize 0

# Fedora's limit is 1 million by default, which really slows down fork() in
# Python / bitbake, because it calls close() for every possible descriptor!
limit descriptors 1024

# Give me "time" usage for any non-bg cmd that takes more than 2s sys & usr time
REPORTTIME=2
TIMEFMT="Time: %*E real %U usr %S sys %P %J"

# This makes forward/backward-word in zle behave like the zsh default, which
# treats word boundaries only on space chars. I set it here explicitly because
# oh-my-zsh hard-codes this to emty string, which makes it behave like bash (yuck!)
WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>'

# I like ls -s to tell me the number of blocks in 1K blocks.
BLOCKSIZE=K ; export BLOCKSIZE

# color-ls This sets LS_COLORS for my dark background
eval `dircolors --sh`

# LS aliases
alias ls='ls --color=auto -Fs'
alias ll='ls --color=auto -lF'
alias la='ls --color=auto -aF'
alias lla='ls --color=auto -latrF'
alias lls='ls --color=auto -ltrF'

# List only directories and symbolic links that point to directories.
# Takes an optional directory name as argument and searches relative to it.
# Parens make whole thing happen in subshell so cd not permanent
function lsd() { 
   ( if [ $1 ]; then 
         \cd $1;
     fi
     ls -ld *(-/DN)
   )
}

function namedir () {
	if [ ! ! "$2" ]
	then
		dir="$2"
	else
		dir="$PWD"
	fi

	eval "$1=$dir"
	echo ~$1 >& /dev/null
}

function up () {
	count=$1
	[ -z "$count" ] && count=1
	local ups
	while [ "$count" -gt 0 ] ; do
	    ups="../$ups"
	    ((count--))
	done
	if [ ! -z "$ups" ] ; then
	    cd "$ups"
	fi
}

alias upp='up 2'
alias uppp='up 3'
alias upppp='up 4'
alias uppppp='up 5'
alias upppppp='up 6'

# Set the gnome-terminal tab title to given string
function settitle() {
	echo -ne "\033]0;$*\007"
}


# These vars only make sense for an interactive shell, so they're in zshrc
export HISTIGNORE=ls:ll:lls:la:c
export HISTSIZE=16384
export SAVEHIST=$HISTSIZE
export HISTFILE=$HOME/.zsh_history

# GREP_OPTIONS was deprecated. My former setting for this was:
# export GREP_OPTIONS='--exclude=*.svn* --directories=recurse --color=auto'
# Note I really hate to drop recursion by default, but -r on the command line
# did not act like --directories=recurse did in that it added an implied .
# argument, so it always grepped everything under the current directory, even
# when you are just piping something into its stdin :(
# As far as I know, I have no recourse but to lose "recursive by default"
alias grep='grep --color=auto'
export GREP_COLOR='1;32'

# These use to be default on Ubuntu, but apparently not on Fedora 22, so
# let's set them explicitly. In particular, -R is needed to get color
# output to look correctly (which was on by default, but became OFF if
# $LESS was set to any string that did not include it!)
export LESS='-R --ignore-case --quit-if-one-screen'

function ..() { cd .. }
## alias cd='cd -L' # This interferes with tab completion on the cd command
alias rm='rm -i'
alias cp='cp -i'
alias c=clear
alias m=less
alias h=history
alias hi='history | tail -25'
alias dh='dirs -v'
alias j='jobs -l'
alias eat='cat > /dev/null'
alias mv="mv -i"
alias a=alias
alias u=unalias
alias mroe=more
function ga { a | egrep $* }
alias sz="source ~/.zshrc"
alias gitags='git ls-files | ctags -L - --sort=foldcase'
alias mktags='find . -name \*.\[ch\] | ctags -L - --sort=foldcase'
alias gba='git branch -a'
alias gbl='git branch -l'
alias gr='git rebase'
alias bb='bitbake'

# A few global aliases of interest
alias -g NF='$(\ls -a *(.om[1]))'    # newest file
alias -g ND='$(\ls -a -d *(/om[1]))' # newest directory
alias -g G='| grep'
alias -g L='| less'
alias -g LL="2>&1 | less"
alias -g NE='2> /dev/null'
alias -g DN=/dev/null

# Pipe output of command to tmux's "clipboard"
alias -g CL='| one-line-strip | tmux load-buffer -'

alias psg='ps -Af | grep '

# Lexmark LPDEV Setup
#alias mlsinit='eval `/m/mls/tools/bin/mlsinit`'
#mlsinit
export MLS_EXPERT=1
export HWSIM_DATA_DIR=~/hwsim_data_dir
alias mstatreal 'mstatus | grep -v "^[?]"'
alias mstatusreal mstatreal

alias sdis='export DISPLAY=$(cat ~/.DISPLAY)'

# Previous globbing-method to do bldtarget completions based on globbing:
#function complete-mls-target () {
#	if [ ! -e bconfig ] ; then
#	    return
#	fi
#
#	targets=( bconfig/*.target )
#	for i in "${targets[@]}" ; do
#	    compadd -- $(echo $i | sed -e 's/bconfig\/\(.*\).target/\1/')
#	done
#}

# Shortened output of the mls 'builds' command.  This works by filtering
# out headers and other undesireable rows, then cutting out only the
# actual build name from the result. For use in bldtarget completion.
function short-build-list () {
    builds | egrep -v '^[>)]|^ *[-A-Z]|^[*]|^$' | cut --delimiter=' ' -f 2
}

function complete-mls-target2 () {
    compadd -- $(short-build-list)
}
compdef complete-mls-target2 bldtarget


# Make ^N always do regular non-smart filename completion
complete-files () { compadd - * }
zle -C dumb-complete complete-word complete-files
bindkey "^[[Z"  dumb-complete # Shift-Tab: Do regular file completion

# Setup key bindings.  For some stupid reason, Home and End keys don't work
# out of the box!
bindkey -e # Emacs bindings
bindkey "\eOH" beginning-of-line # Normal Home & end
bindkey "\eOF" end-of-line
bindkey "\e[1~" beginning-of-line # Home & end in screen + ssh
bindkey "\e[4~" end-of-line
bindkey "^F" forward-word   # Was forward-char. Default binding is M-f
bindkey "^B" backward-word  # Was backward-char. Default binding is M-b
bindkey "^P" push-input     # Was push-line
bindkey "^G" get-line       # Was send-break
bindkey "^[[3~" delete-char # DEL key - delete char from right
bindkey "^Z"    undo        # Undo effect of last keystroke. Default biding is C-xC-u
bindkey "^X^I"  redo        # Wanted to use ^X^R, but that is taken by _read_comp.
                            # Also wanted to use C-xC-S-u, but zle can't do Ctrl+Shift!
bindkey "\ea" universal-argument # Original binding: accept-and-hold, which is useless
                                 # Want to use ^U, like emacs, but that means kill input

## Abortive attempt to get zsh to auto-load config changes. Problem is that
export PATH=~/bin:$PATH

# 256-color support with Tmux compatibility:
# We need $TERM to be xterm-256color outside of Tmux but don't override
# Tmux's setting of screen-256color inside Tmux
[[ "$TERM" =~ "screen*" ]] || TERM=xterm-256color

# tmux 1.9 broke compatibility with screen-256color because it actually honors
# the application's request for "standout" mode rather than translating that
# into something that meant reverse video. And screen-256color had defined
# standout to look italicized and had never define an italicized mode.
# As a result search highlights in "less" appear italicized instead of reverse
# video, which is hard to see!
# So, define my own derivative terminfo that makes standout look like reverse
# video, and adds a definition for italics that looks itaics.
[[ "$TERM" = "screen-256color" && -e ~/.terminfo/s/screen-256color-it ]] && TERM=screen-256color-it

## the vars I set do not persist (treated as local no matter what I do). Grr!
# function periodic() {
#     #typeset -g periodic_cur periodic_prev
#     #export periodic_cur
#     #export periodic_prev
#     echo debug: c $periodic_cur  p $periodic_prev
#     periodic_cur="$(stat --format=%Y ~/.zshrc) $(stat --format=%Y ~/.zsh/rc-common)"
#     echo debug: c $periodic_cur  p $periodic_prev
#     if [ "$periodic_prev" != "$periodic_cur" ] ; then
#         if [ ! -z "$periodic_prev" ] ; then
#             echo Re-reading .zshrc...
#             source ~/.zshrc
#         fi
#         periodic_cur="$periodic_prev"
#     fi
#     return 0
# }
# PERIOD=60

