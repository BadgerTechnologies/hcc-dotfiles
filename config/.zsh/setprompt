# Setup hcochran's prompt.
# We expect that ~/.zsh/gencolors has already been sourced by this shell, so
# that all the color strings therein are already defined.

setopt PROMPT_SUBST

_can_i_sudo() {
    sudo -n true 2>/dev/null
}

# Options for the gitfast/git-prompt plugin from oh-my-zsh
GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWSTASHSTATE=1
GIT_PS1_SHOWUPSTREAM="auto verbose"
GIT_PS1_DESCRIBE_STYLE="branch"
GIT_PS1_SHOWCOLORHINTS=1

function hccprompt {
    # We choose yellow because it stands out. Makes it easy to find
    # command boundary in terminal scroll-back buffer
    local maincolor="%{$hyellow%}"

    # Opening and Time of Day
    PS1="${maincolor}===[%T"

    # If in Docker container, print the container name
    local dockercolor="%{$hblue%}"
    if [[ -n $DOCKER_NAME ]] ; then
        PS1+=" ${dockercolor}$DOCKER_NAME"
    fi

    # ptag variable. User can set this to "tag" this shell
    local ptagcolor="$hcyan"
    if [[ -n $ptag ]]; then
        PS1+=" ${ptagcolor}${ptag}"
    fi

    # Hostname, up to first dot
    PS1+=" ${hgreen}%m${maincolor}"

    # Show a flag if this shell has cached Sudo permission
    _can_i_sudo && PS1+=" ${hred}SUDO"

    # Close the bracketed section
    PS1+="${maincolor}]"

    # Exit status if command exited with Error.
    PS1+="%0(?,, $bgred$hwhite Exit %? $norm${maincolor})"

    # Git info, using the gitfast/git-prompt plugin from oh-my-zsh. In
    # colorizing, it uses %f to "return to the default color (white)".  But the
    # "default color" of my prompt is not white, so do a replacement. I could
    # probably change the shell's default color instead, but this would make
    # command text be that color, which is not what I want.
    local git_info="$(__git_ps1)"
    PS1+="${git_info//\%f/${maincolor}}"

    # Current directory and newline
    PS1+="${maincolor} %~/
==>${norm} "

}
autoload -Uz add-zsh-hook
add-zsh-hook precmd hccprompt

# Show Elapsed wall-clock time for any command that takes longer
# than 1 second. This is like $REPORTTIME except that the threshold is
# real time rather than user+system CPU time.
__real_seconds() {
    echo $(( $(date '+%s + %N') / 1000000000.0 ))
}

__record_start_time() {
    # Used in elapsed time calculation in the prompt
    _start=$(__real_seconds)
}
add-zsh-hook preexec __record_start_time

__show_elapsed() {
    # Show how long the previous command took if more than 1 second
    if (($+_start)); then
        local elapsed=$(( $(__real_seconds)-_start ))
        unset _start
        (($elapsed > 1.0)) && printf "${hcyan}Elapsed: %.3f${norm}\n" $elapsed >&2
    fi
}
add-zsh-hook precmd __show_elapsed


# Emit a terminal bell if last command exited with non-zero status. This makes
# the tmux window label change to "alert" color. Used to do this in the prompt
# but it would re-asert alert status every time the prompt was redrawn, causing
# lots of false alerts. Doing it in precmd means it will happen only once.
__bell_on_error() {
    [[ $? != 0 ]] && echo -n "\a"
}
add-zsh-hook precmd __bell_on_error

alias sp='source ~/.zsh/setprompt'
